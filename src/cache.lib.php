<?php

if (!defined('SUCURISCAN_INIT') || SUCURISCAN_INIT !== true) {
    if (!headers_sent()) {
        /* Report invalid access if possible. */
        header('HTTP/1.1 403 Forbidden');
    }
    exit(1);
}

/**
 * File-based cache library.
 *
 * WP_Object_Cache [1] is WordPress' class for caching data which may be
 * computationally expensive to regenerate, such as the result of complex
 * database queries. However the object cache is non-persistent. This means that
 * data stored in the cache resides in memory only and only for the duration of
 * the request. Cached data will not be stored persistently across page loads
 * unless of the installation of a 3party persistent caching plugin [2].
 *
 * [1] https://codex.wordpress.org/Class_Reference/WP_Object_Cache
 * [2] https://codex.wordpress.org/Class_Reference/WP_Object_Cache#Persistent_Caching
 */
class SucuriScanCache extends SucuriScan
{
    /**
     * The unique name (or identifier) of the file with the data.
     *
     * The file should be located in the same folder where the dynamic data
     * generated by the plugin is stored, and using the following format [1], it
     * most be a PHP file because it is expected to have an exit point in the first
     * line of the file causing it to stop the execution if a unauthorized user
     * tries to access it directly.
     *
     * [1] /public/data/sucuri-DATASTORE.php
     *
     * @var null|string
     */
    private $datastore = null;

    /**
     * The full path of the datastore file.
     *
     * @var string
     */
    private $datastore_path = '';

    /**
     * Whether the datastore file is usable or not.
     *
     * This variable will only be TRUE if the datastore file specified exists, is
     * writable and readable, in any other case it will always be FALSE.
     *
     * @var boolean
     */
    private $usable_datastore = false;

    /**
     * Class constructor.
     *
     * @param  string $datastore Unique name (or identifier) of the file with the data.
     * @return void
     */
    public function __construct($datastore = '', $auto_create = true)
    {
        $this->datastore = $datastore;
        $this->datastore_path = $this->datastoreFilePath($auto_create);
        $this->usable_datastore = (bool) $this->datastore_path;
    }

    /**
     * Default attributes for every datastore file.
     *
     * @return string Default attributes for every datastore file.
     */
    private function datastoreDefaultInfo()
    {
        $attrs = array(
            'datastore' => $this->datastore,
            'created_on' => time(),
            'updated_on' => time(),
        );

        return $attrs;
    }

    /**
     * Default content of every datastore file.
     *
     * @param  array  $finfo Rainbow table with the key names and decoded values.
     * @return string        Default content of every datastore file.
     */
    private function datastoreInfo($finfo = array())
    {
        $attrs = $this->datastoreDefaultInfo();
        $info_is_available = (bool) isset($finfo['info']);
        $info  = "<?php\n";

        foreach ($attrs as $attr_name => $attr_value) {
            if ($info_is_available
                && $attr_name != 'updated_on'
                && isset($finfo['info'][$attr_name])
            ) {
                $attr_value = $finfo['info'][$attr_name];
            }

            $info .= sprintf("// %s=%s;\n", $attr_name, $attr_value);
        }

        $info .= "exit(0);\n";
        $info .= "?>\n";

        return $info;
    }

    /**
     * Check if the datastore file exists, if it's writable and readable by the same
     * user running the server, in case that it does not exists the function will
     * tries to create it by itself with the right permissions to use it.
     *
     * @param  boolean $auto_create Automatically create the file if not exists or not.
     * @return string               The full path where the datastore file is located, FALSE otherwise.
     */
    private function datastoreFilePath($auto_create = false)
    {
        if (!is_null($this->datastore)) {
            $folder_path = $this->dataStorePath();
            $file_path = $folder_path . '/sucuri-' . $this->datastore . '.php';

            // Create the datastore parent directory.
            if (!file_exists($folder_path)) {
                @mkdir($folder_path, 0755, true);
            }

            // Create the datastore file is it does not exists and the folder is writable.
            if (!file_exists($file_path)
                && is_writable($folder_path)
                && $auto_create === true
            ) {
                @file_put_contents($file_path, $this->datastoreInfo());
            }

            // Continue the operation after an attemp to create the datastore file.
            if (file_exists($file_path)
                && is_writable($file_path)
                && is_readable($file_path)
            ) {
                return $file_path;
            }
        }

        return false;
    }

    /**
     * Define the pattern for the regular expression that will check if a cache key
     * is valid or not, and also will help the function that parses the file to see
     * which characters of each line are the keys are which are the values.
     *
     * @param  string $action Either "valid", "content", or "header".
     * @return string Cache key pattern.
     */
    private function keyPattern($action = 'valid')
    {
        if ($action == 'valid') {
            return '/^([0-9a-zA-Z_]+)$/';
        } elseif ($action == 'content') {
            return '/^([0-9a-zA-Z_]+):(.+)/';
        } elseif ($action == 'header') {
            return '/^\/\/ ([a-z_]+)=(.*);$/';
        }

        return false;
    }

    /**
     * Check whether a key has a valid name or not.
     *
     * @param  string  $key Unique name to identify the data in the datastore file.
     * @return boolean      TRUE if the format of the key name is valid, FALSE otherwise.
     */
    private function validKeyName($key = '')
    {
        return (bool) @preg_match($this->keyPattern('valid'), $key);
    }

    /**
     * Update the content of the datastore file with the new entries.
     *
     * @param  array   $finfo Rainbow table with the key names and decoded values.
     * @return boolean        TRUE if the operation finished successfully, FALSE otherwise.
     */
    private function saveNewEntries($finfo = array())
    {
        $data_string = $this->datastoreInfo($finfo);

        if (!empty($finfo)) {
            foreach ($finfo['entries'] as $key => $data) {
                if ($this->validKeyName($key)) {
                    $data = json_encode($data);
                    $data_string .= sprintf("%s:%s\n", $key, $data);
                }
            }
        }

        return (bool) @file_put_contents($this->datastore_path, $data_string);
    }

    /**
     * Retrieve and parse the datastore file, and generate a rainbow table with the
     * key names and decoded data as the values of each entry. Duplicated key names
     * will be removed automatically while adding the keys to the array and their
     * values will correspond to the first occurrence found in the file.
     *
     * @param  boolean $assoc When TRUE returned objects will be converted into associative arrays.
     * @return array          Rainbow table with the key names and decoded values.
     */
    private function getDatastoreContent($assoc = false)
    {
        $data_object = array(
            'info' => array(),
            'entries' => array(),
        );

        if ($this->usable_datastore) {
            $data_lines = SucuriScanFileInfo::fileLines($this->datastore_path);

            if (!empty($data_lines)) {
                foreach ($data_lines as $line) {
                    if (preg_match($this->keyPattern('header'), $line, $match)) {
                        $data_object['info'][ $match[1] ] = $match[2];
                    } elseif (preg_match($this->keyPattern('content'), $line, $match)) {
                        if ($this->validKeyName($match[1])
                            && !array_key_exists($match[1], $data_object)
                        ) {
                            $data_object['entries'][$match[1]] = @json_decode($match[2], $assoc);
                        }
                    }
                }
            }
        }

        return $data_object;
    }

    /**
     * Retrieve the headers of the datastore file.
     *
     * Each datastore file has a list of attributes at the beginning of the it with
     * information like the creation and last update time. If you are extending the
     * functionality of these headers please refer to the function that contains the
     * default attributes and their values [1].
     *
     * [1] SucuriScanCache::datastoreDefaultInfo()
     *
     * @return array Default content of every datastore file.
     */
    public function getDatastoreInfo()
    {
        $finfo = $this->getDatastoreContent();

        if (!empty($finfo['info'])) {
            $finfo['info']['fpath'] = $this->datastore_path;

            return $finfo['info'];
        }

        return false;
    }

    /**
     * Get the total number of unique entries in the datastore file.
     *
     * @param  array   $finfo Rainbow table with the key names and decoded values.
     * @return integer        Total number of unique entries found in the datastore file.
     */
    public function getCount($finfo = null)
    {
        if (!is_array($finfo)) {
            $finfo = $this->getDatastoreContent();
        }

        return count($finfo['entries']);
    }

    /**
     * Check whether the last update time of the datastore file has surpassed the
     * lifetime specified for a key name. This function is the only one related with
     * the caching process, any others besides this are just methods used to handle
     * the data inside those files.
     *
     * @param  integer $lifetime Life time of the key in the datastore file.
     * @param  array   $finfo    Rainbow table with the key names and decoded values.
     * @return boolean           TRUE if the life time of the data has expired, FALSE otherwise.
     */
    public function dataHasExpired($lifetime = 0, $finfo = null)
    {
        if (is_null($finfo)) {
            $finfo = $this->getDatastoreContent();
        }

        if ($lifetime > 0 && !empty($finfo['info'])) {
            $diff_time = time() - intval($finfo['info']['updated_on']);

            if ($diff_time >= $lifetime) {
                return true;
            }
        }

        return false;
    }

    /**
     * Execute the action using the key name and data specified.
     *
     * @param  string  $key      Unique name to identify the data in the datastore file.
     * @param  string  $data     Mixed data stored in the datastore file following the unique key name.
     * @param  string  $action   Either add, set, get, or delete.
     * @param  integer $lifetime Life time of the key in the datastore file.
     * @param  boolean $assoc    When TRUE returned objects will be converted into associative arrays.
     * @return boolean           TRUE if the operation finished successfully, FALSE otherwise.
     */
    private function handleKeyData($key = '', $data = null, $action = '', $lifetime = 0, $assoc = false)
    {
        if ($this->validKeyName($key)
            && $this->usable_datastore
        ) {
            $finfo = $this->getDatastoreContent($assoc);

            if ($action == 'set' || $action == 'add') {
                $finfo['entries'][$key] = $data;

                return $this->saveNewEntries($finfo);
            } elseif ($action == 'get') {
                if (!$this->dataHasExpired($lifetime, $finfo)
                    && array_key_exists($key, $finfo['entries'])
                ) {
                    return $finfo['entries'][$key];
                }
            } elseif ($action == 'get_all') {
                if (!$this->dataHasExpired($lifetime, $finfo)) {
                    return $finfo['entries'];
                }
            } elseif ($action == 'exists') {
                if (!$this->dataHasExpired($lifetime, $finfo)
                    && array_key_exists($key, $finfo['entries'])
                ) {
                    return true;
                }
            } elseif ($action == 'delete') {
                unset($finfo['entries'][$key]);

                return $this->saveNewEntries($finfo);
            }
        }

        return false;
    }

    /**
     * JSON-encode the data and store it in the datastore file identifying it with
     * the key name, the data will be added to the file even if the key is
     * duplicated, but when getting the value of the same key later again it will
     * return only the value of the first occurrence found in the file.
     *
     * @param  string  $key  Unique name to identify the data in the datastore file.
     * @param  string  $data Mixed data stored in the datastore file following the unique key name.
     * @return boolean       TRUE if the data was stored successfully, FALSE otherwise.
     */
    public function add($key = '', $data = '')
    {
        return $this->handleKeyData($key, $data, 'add');
    }

    /**
     * Update the data of all the key names matching the one specified.
     *
     * @param  string  $key  Unique name to identify the data in the datastore file.
     * @param  string  $data Mixed data stored in the datastore file following the unique key name.
     * @return boolean       TRUE if the data was stored successfully, FALSE otherwise.
     */
    public function set($key = '', $data = '')
    {
        return $this->handleKeyData($key, $data, 'set');
    }

    /**
     * Retrieve the first occurrence of the key found in the datastore file.
     *
     * @param  string  $key      Unique name to identify the data in the datastore file.
     * @param  integer $lifetime Life time of the key in the datastore file.
     * @param  boolean $assoc    When TRUE returned objects will be converted into associative arrays.
     * @return string            Mixed data stored in the datastore file following the unique key name.
     */
    public function get($key = '', $lifetime = 0, $assoc = false)
    {
        $assoc = ($assoc == 'array' ? true : $assoc);

        return $this->handleKeyData($key, null, 'get', $lifetime, $assoc);
    }

    /**
     * Retrieve all the entries found in the datastore file.
     *
     * @param  integer $lifetime Life time of the key in the datastore file.
     * @param  boolean $assoc    When TRUE returned objects will be converted into associative arrays.
     * @return string            Mixed data stored in the datastore file following the unique key name.
     */
    public function getAll($lifetime = 0, $assoc = false)
    {
        $assoc = ($assoc == 'array' ? true : $assoc);

        return $this->handleKeyData('temp', null, 'get_all', $lifetime, $assoc);
    }

    /**
     * Check whether a specific key exists in the datastore file.
     *
     * @param  string  $key Unique name to identify the data in the datastore file.
     * @return boolean      TRUE if the key exists in the datastore file, FALSE otherwise.
     */
    public function exists($key = '')
    {
        return $this->handleKeyData($key, null, 'exists');
    }

    /**
     * Delete any entry from the datastore file matching the key name specified.
     *
     * @param  string  $key Unique name to identify the data in the datastore file.
     * @return boolean      TRUE if the entries were removed, FALSE otherwise.
     */
    public function delete($key = '')
    {
        return $this->handleKeyData($key, null, 'delete');
    }

    /**
     * Remove all the entries from the datastore file.
     *
     * @return boolean Always TRUE unless the datastore file is not writable.
     */
    public function flush()
    {
        $finfo = $this->getDatastoreContent();

        if (array_key_exists('entries', $finfo)) {
            $finfo['entries'] = array();
        }

        return $this->saveNewEntries($finfo);
    }
}
